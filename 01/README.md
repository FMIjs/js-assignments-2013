#Задача 1

##n-кратно прилагане

Реализирайте композиция на една функция сама със себе си n пъти.
Разширете прототипа на функциите с метод `times`, който приема едно цяло число `n` и връща функция, която е n-кратното прилагане на функцията върху която е извикан.

```javascript
> var add_two = function (num) { return num + 2; };
> var add_six = add_two.times(3);
> add_six(2);
8
```

 * Функцията върху която ще извикваме методът, който сте написали *винаги ще очаква само един аргумент*.
 * Методът, който дефинирате винаги ще бъде извикван с точно един аргумент - цяло число.
 * Ако аргументът на `times` е по-малък от 1, третирайте го като 1;

##Array to set
Разширете прототипа на списъците с метод `unique`, който връща списък с уникалните елементи в оригиналния списък.
Два обекта `a` и `b` ще са уникални, ако `a == b` се оценява до `true`.

```javascript
> var l1 = [1, 2, 3, 4, 5, 5, 5, 4, 6, 4];
> l1.unique();
[1, 2, 3, 4, 5, 6] //order IS NOT important
```

####*NB!*: Редът на елементите в резултата _няма значние_. Необходимо е само да са различни.

##array intersection
Разширете прототипа на списъците с метод `intersect`, който прави сечение на два списъка.

####*NB!*: Резултатът се разглежда като множество. Редът на елементите _няма значние_. Елементите трябва _да не се повтарят_.

```javascript
> var some_numbers = [1, 2, 3, 4, 5];
> var some_other_numbers = [5, 4, 7, 10, 12, 2, 1];
> some_other_numbers.intersect(some_numbers);
[1, 4, 2, 5] //order IS NOT important
```
